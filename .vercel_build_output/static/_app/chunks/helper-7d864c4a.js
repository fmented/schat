var G=Object.defineProperty,L=Object.defineProperties;var $=Object.getOwnPropertyDescriptors;var U=Object.getOwnPropertySymbols;var N=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var K=(s,t,e)=>t in s?G(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,m=(s,t)=>{for(var e in t||(t={}))N.call(t,e)&&K(s,e,t[e]);if(U)for(var e of U(t))R.call(t,e)&&K(s,e,t[e]);return s},b=(s,t)=>L(s,$(t));var A=(s,t,e)=>{if(!t.has(s))throw TypeError("Cannot "+e)};var l=(s,t,e)=>(A(s,t,"read from private field"),e?e.call(s):t.get(s)),P=(s,t,e)=>{if(t.has(s))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(s):t.set(s,e)},v=(s,t,e,n)=>(A(s,t,"write to private field"),n?n.call(s,e):t.set(s,e),e);var d=(s,t,e)=>(A(s,t,"access private method"),e);import{T as H,P as W}from"./vendor-1841b722.js";import{s as M,A as j}from"./index-a1babe66.js";const z=()=>{const s=H("__svelte__");return{page:{subscribe:s.page.subscribe},navigating:{subscribe:s.navigating.subscribe},get preloading(){return console.error("stores.preloading is deprecated; use stores.navigating instead"),{subscribe:s.navigating.subscribe}},session:s.session,updated:s.updated}},B=s=>{throw new Error(`Cannot ${s} session store before subscribing`)},I={subscribe(s){const t=z().session;return I.set=t.set,I.update=t.update,t.subscribe(s)},set:()=>B("set"),update:()=>B("update")};class k extends Array{sortBy(t,e=!1){if(!this.length)return this;if(!(t in this[0]))return this;const n=e?-1:1,r=(o,c)=>o[t]<c[t]?-1*n:o[t]>c[t]?1*n:0;return this.sort(r),this}}function _(s,t){return T(s)?s(t):typeof s=="object"?Object.keys(s).every(e=>{const n=s[e],r=s[e];return _(n,r)}):s===t}function q(s,t){return T(s)?s(t):typeof s=="object"?Object.keys(s).some(e=>{const n=s[e],r=s[e];return q(n,r)}):s===t}function T(s){return typeof s=="function"}var h,D,w,y;class F{constructor(t,e){P(this,w);P(this,h,void 0);P(this,D,void 0);v(this,h,t),v(this,D,e)}search(t,{index:e,direction:n}={}){const r=new k,o=d(this,w,y).call(this,"readonly");return new Promise((c,i)=>{const u=e?o.objectStore(l(this,h)).index(e).openCursor(null,n):o.objectStore(l(this,h)).openCursor(null,n);Object.keys(t).length===0&&c(r),u.onsuccess=()=>{const a=u.result;if(a){const p=a.value,f=a.primaryKey;q(t,p)&&r.push(b(m({},p),{$pk:f,update:S=>{const E=m(m({},p),S);return this.update(f,E)},delete:()=>this.delete(f)})),a.continue()}},o.oncomplete=()=>c(r),o.onerror=a=>i(a),u.onerror=a=>i(a)})}searchOne(t,{index:e,direction:n}={}){let r;const o=d(this,w,y).call(this,"readonly");return new Promise((c,i)=>{const u=e?o.objectStore(l(this,h)).index(e).openCursor(null,n):o.objectStore(l(this,h)).openCursor(null,n);Object.keys(t).length===0&&c(null),u.onsuccess=()=>{const a=u.result;if(a){const p=a.value,f=a.primaryKey;if(q(t,p)){r=b(m({},p),{$pk:f,update:S=>this.update(f,m(m({},p),S)),delete:()=>this.delete(f)});return}a.continue()}},o.oncomplete=()=>c(r),o.onerror=a=>i(a),u.onerror=a=>i(a)})}find(t,{index:e,direction:n}={}){const r=new k,o=d(this,w,y).call(this,"readonly");return new Promise((c,i)=>{const u=e?o.objectStore(l(this,h)).index(e).openCursor(null,n):o.objectStore(l(this,h)).openCursor(null,n);Object.keys(t).length===0&&c(r),u.onsuccess=()=>{const a=u.result;if(a){const p=a.value,f=a.primaryKey;_(t,p)&&r.push(b(m({},p),{$pk:f,update:S=>{const E=m(m({},p),S);return this.update(f,E)},delete:()=>this.delete(f)})),a.continue()}},o.oncomplete=()=>c(r),o.onerror=a=>i(a),u.onerror=a=>i(a)})}findOne(t,{index:e,direction:n}={}){let r;const o=d(this,w,y).call(this,"readonly");return new Promise((c,i)=>{const u=e?o.objectStore(l(this,h)).index(e).openCursor(null,n):o.objectStore(l(this,h)).openCursor(null,n);Object.keys(t).length===0&&c(null),u.onsuccess=()=>{const a=u.result;if(a){const p=a.value,f=a.primaryKey;if(_(t,p)){r=b(m({},p),{$pk:f,update:S=>this.update(f,m(m({},p),S)),delete:()=>this.delete(f)});return}a.continue()}},o.oncomplete=()=>c(r),o.onerror=a=>i(a),u.onerror=a=>i(a)})}includes(t){let e=!1;const n=d(this,w,y).call(this,"readonly");return new Promise((r,o)=>{const c=n.objectStore(l(this,h)).openCursor();c.onerror=i=>o(i),c.onsuccess=()=>{const i=c.result;if(i){if(_(t,i.value))return e=!0;i.continue()}else return},n.oncomplete=()=>r(e),n.onerror=i=>o(i)})}has(t){let e=!1;const n=d(this,w,y).call(this,"readonly");return new Promise((r,o)=>{const c=n.objectStore(l(this,h)).openCursor();c.onerror=i=>o(i),c.onsuccess=()=>{const i=c.result;if(i){if(q(t,i.value))return e=!0;i.continue()}else return},n.oncomplete=()=>r(e),n.onerror=i=>o(i)})}async insertOne(t){const e=d(this,w,y).call(this);return new Promise((n,r)=>{const o=e.objectStore(l(this,h)).add(t);o.onerror=c=>r(c),o.onsuccess=c=>e.onerror=i=>r(i),e.oncomplete=c=>n()})}async insertMany(t){const e=t.map(async n=>await this.insertOne(n));return Promise.all(e)}async delete(t){const e=d(this,w,y).call(this);return new Promise((n,r)=>{const o=e.objectStore(l(this,h)).delete(t);o.onsuccess=()=>o.onerror=c=>r(c),e.oncomplete=()=>n(),e.onerror=c=>r(c)})}deleteMany(t){const e=[...t].map(async n=>this.delete(n));return Promise.all(e)}update(t,e){const n=d(this,w,y).call(this);return new Promise((r,o)=>{const c=n.objectStore(l(this,h)).put(e,t);c.onsuccess=()=>c.onerror=i=>o(i),n.oncomplete=()=>r(),n.onerror=i=>o(i)})}updateMany(t){const e=[...t.entries()].map(async([n,r])=>{await this.update(n,r)});return Promise.all(e)}clear(){const t=d(this,w,y).call(this);return new Promise((e,n)=>{const r=t.objectStore(l(this,h)).clear();r.onerror=o=>n(o),r.onsuccess=o=>t.oncomplete=()=>e(),t.onerror=o=>n(o)})}count(){const t=d(this,w,y).call(this,"readonly");return new Promise((e,n)=>{const r=t.objectStore(l(this,h)).count();r.onsuccess=()=>r.onerror=o=>n(o),t.oncomplete=()=>e(r.result),t.onerror=o=>n(o)})}get(t){let e;const n=d(this,w,y).call(this,"readonly");return new Promise((r,o)=>{const c=n.objectStore(l(this,h)).openCursor(),i=n.objectStore(l(this,h)).get(t);c.onsuccess=()=>{const u=i.result;e=b(m({},u),{$pk:t,update:a=>{const p=Object.assign(u,a);return this.update(t,p)},delete:()=>this.delete(t)})},n.oncomplete=()=>r(e),n.onerror=u=>o(u),c.onerror=u=>o(u)})}async getMany(t){const e=[...t].map(n=>this.get(n));return new k(...await Promise.all(e))}all({index:t,direction:e}={}){const n=d(this,w,y).call(this,"readonly"),r=new k;return new Promise((o,c)=>{const i=t?n.objectStore(l(this,h)).index(t).openCursor(null,e):n.objectStore(l(this,h)).openCursor(null,e);i.onsuccess=()=>{const u=i.result;u&&(r.push(b(m({},u.value),{$pk:u.primaryKey})),u.continue())},n.oncomplete=()=>o(r),n.onerror=u=>c(u),i.onerror=u=>c(u)})}retrieve(t,{index:e,direction:n}={}){const r=new k,o=d(this,w,y).call(this,"readonly");return new Promise((c,i)=>{const u=e?o.objectStore(l(this,h)).index(e).openCursor(null,n):o.objectStore(l(this,h)).openCursor(null,n);u.onsuccess=()=>{const a=u.result;if(a){const p=t(a.value);p!==void 0&&r.push(p),a.continue()}},o.oncomplete=()=>c(r),o.onerror=a=>i(a),u.onerror=a=>i(a)})}retrieveOne(t,{index:e,direction:n}={}){let r=null;const o=d(this,w,y).call(this,"readonly");return new Promise((c,i)=>{const u=e?o.objectStore(l(this,h)).index(e).openCursor(null,n):o.objectStore(l(this,h)).openCursor(null,n);u.onsuccess=()=>{const a=u.result;if(a){const p=t(a.value);if(p!==void 0)return r=p;a.continue()}},u.onerror=a=>i(a),o.oncomplete=()=>c(r),o.onerror=a=>i(a)})}}h=new WeakMap,D=new WeakMap,w=new WeakSet,y=function(t="readwrite"){return l(this,D).transaction(l(this,h),t)};var x,C,g;class J{constructor(t,e){P(this,x,void 0);P(this,C,void 0);P(this,g,void 0);v(this,C,t),v(this,x,e);const n=this,r={get(o,c){if(!l(n,g))throw new Error("Database is not opened");return new F(c,l(n,g))}};this.tables=new Proxy({},r)}get name(){return l(this,C)}async open(){if(!l(this,g))return new Promise((t,e)=>{const n=indexedDB.open(l(this,C));n.onupgradeneeded=()=>{const r=n.result;for(const o in l(this,x)){const c=r.createObjectStore(o,{autoIncrement:!0});for(const i of l(this,x)[o])c.createIndex(i.name,i.name,i.unique?{unique:!0}:{})}v(this,g,r),t()},n.onsuccess=()=>{v(this,g,n.result),t()},n.onerror=r=>e(r)})}async close(){if(!l(this,g))return;const t=l(this,g);return v(this,g,void 0),t.close()}async delete(){return l(this,g)&&await this.close(),new Promise((t,e)=>{const n=indexedDB.deleteDatabase(l(this,C));n.onsuccess=()=>t(),n.onerror=r=>e(r)})}}x=new WeakMap,C=new WeakMap,g=new WeakMap;function Y(s){return new J(s,{chat:[{name:"from"},{name:"to"},{name:"content"},{name:"timeStamp"},{name:"id",unique:!0},{name:"status"}],profile:[{name:"username",unique:!0},{name:"bio"},{name:"avatar"}]})}async function Z(s){await s.open();const e=(await s.tables.profile.all()).map(async r=>{const{content:o,timeStamp:c,from:i,status:u,to:a,id:p}=await s.tables.chat.searchOne({from:r.username,to:r.username},{direction:"prev"});return{with:r.username,pic:r.avatar,content:o,timeStamp:c,from:i,status:u,to:a,id:p,delete:async()=>{await s.open();const O=(await s.tables.chat.search({from:r.username,to:r.username})).map(async S=>await S.delete());await Promise.all(O),await s.close()}}});return await s.close(),await Promise.all(e)}async function tt(s,t){await s.open();const e=(await s.tables.chat.search({from:t,to:t})).map(n=>b(m({},n),{delete:async()=>{await s.open(),await n.delete(),await s.close()}}));return await s.close(),e}async function et(s,t){const e=W(),n=Date.now(),r=b(m({},t),{id:e,timeStamp:n});if(await s.open(),!await s.tables.profile.has({username:t.to})){const c=await(await M(j.AUTH_DETAIL,{username:t.to})).json();await s.tables.profile.insertOne({username:t.to,avatar:c.avatar,bio:c.bio})}await s.close();try{if((await M(j.MESSAGE_SEND,r)).ok){await s.open(),await s.tables.chat.insertOne(b(m({},r),{status:"sent"}));const i=(await s.tables.chat.find({status:"pending"})).map(async u=>{try{(await M(j.MESSAGE_SEND,u)).ok&&await u.update({status:"sent"})}catch{return}});await Promise.all(i),await s.close()}else await s.open(),await s.tables.chat.insertOne(b(m({},r),{status:"pending"})),await s.close()}catch{await s.open(),await s.tables.chat.insertOne(b(m({},r),{status:"pending"})),await s.close()}}export{tt as a,et as b,Z as g,Y as i,I as s};
